From a2f08a919c72af29c56b937e6c92eb104037fed5 Mon Sep 17 00:00:00 2001
From: Nelson Escobar <neescoba@cisco.com>
Date: Tue, 22 Mar 2016 13:42:08 -0700
Subject: [PATCH 22/22]     bonding: fix bond link detect in non-interrupt mode

    Stopping then re-starting a bond interface containing slaves that
    used polling for link detection caused the bond to think all slave
    links were down and inactive.

    Move the start of the polling for link from slave_add() to
    bond_ethdev_start() and in bond_ethdev_stop() make sure we clear
    the last_link_status of the slaves.

    Signed-off-by: Nelson Escobar <neescoba@cisco.com>
    Signed-off-by: John Daley <johndale@cisco.com>
---
 drivers/net/bonding/rte_eth_bond_pmd.c | 27 +++++++++++++++++----------
 1 file changed, 17 insertions(+), 10 deletions(-)

diff --git a/drivers/net/bonding/rte_eth_bond_pmd.c b/drivers/net/bonding/rte_eth_bond_pmd.c
index b1373c6..d32c6f5 100644
--- a/drivers/net/bonding/rte_eth_bond_pmd.c
+++ b/drivers/net/bonding/rte_eth_bond_pmd.c
@@ -1447,18 +1447,11 @@ slave_add(struct bond_dev_private *internals,
 	slave_details->port_id = slave_eth_dev->data->port_id;
 	slave_details->last_link_status = 0;
 
-	/* If slave device doesn't support interrupts then we need to enabled
-	 * polling to monitor link status */
+	/* Mark slave devices that don't support interrupts so we can
+	 * compensate when we start the bond
+	 */
 	if (!(slave_eth_dev->data->dev_flags & RTE_ETH_DEV_INTR_LSC)) {
 		slave_details->link_status_poll_enabled = 1;
-
-		if (!internals->link_status_polling_enabled) {
-			internals->link_status_polling_enabled = 1;
-
-			rte_eal_alarm_set(internals->link_status_polling_interval_ms * 1000,
-					bond_ethdev_slave_link_status_change_monitor,
-					(void *)&rte_eth_devices[internals->port_id]);
-		}
 	}
 
 	slave_details->link_status_wait_to_complete = 0;
@@ -1543,6 +1536,18 @@ bond_ethdev_start(struct rte_eth_dev *eth_dev)
 					eth_dev->data->port_id, internals->slaves[i].port_id);
 			return -1;
 		}
+		/* We will need to poll for link status if any slave doesn't
+		 * support interrupts
+		 */
+		if (internals->slaves[i].link_status_poll_enabled)
+			internals->link_status_polling_enabled = 1;
+	}
+	/* start polling if needed */
+	if (internals->link_status_polling_enabled) {
+		rte_eal_alarm_set(
+			internals->link_status_polling_interval_ms * 1000,
+			bond_ethdev_slave_link_status_change_monitor,
+			(void *)&rte_eth_devices[internals->port_id]);
 	}
 
 	if (internals->user_defined_primary_port)
@@ -1615,6 +1620,8 @@ bond_ethdev_stop(struct rte_eth_dev *eth_dev)
 
 	internals->active_slave_count = 0;
 	internals->link_status_polling_enabled = 0;
+	for (i = 0; i < internals->slave_count; i++)
+		internals->slaves[i].last_link_status = 0;
 
 	eth_dev->data->dev_link.link_status = 0;
 	eth_dev->data->dev_started = 0;
-- 
1.9.1

